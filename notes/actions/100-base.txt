Elixir – это динамический язык программирования, а значит, переменные и их тип не должны быть объявлены в явном виде.
monthly_salary = 10000
----------------------------------------------------
Модуль – это группа функций, что-то вроде пространства имен. Функции в Elixir должны быть определены внутри модуля.
По умолчанию в Elixir доступна стандартная библиотека, содержащая множест­во модулей. Например, модуль IO может быть использован для осуществления различных операций ввода-вывода. При помощи функции puts этого модуля можно
вывести текст на экран:
> IO.puts("Hello World!")
Чтобы определить свой собственный модуль, используйте конструкцию defmodule, а функции внутри модуля нужно объявлять при помощи конструкции def.
defmodule Geometry do
	def rectangle_area(a, b) do
		a * b
	end
end
Модуль можно включить в работу двумя способами. Первый – скопировать этот код прямо в iex. Второй – дать оболочке команду интерпретировать файл, прописав:
$ iex geometry.ex
в одном файле можно создать сколько угодно модулей
Имя модуля должно начинаться с прописной буквы и следовать «верблюжьему» стилю именования (CamelCase).
Точки обычно используются для организации иерархической структуры модулей:
defmodule Geometry.Rectangle do ...
defmodule Geometry.Circle do...
Можно также создавать вложенные модули:
defmodule Geometry do
		defmodule Rectangle do...
------------------------------------------------------
Функции в Elixir всегда являются частью модуля.
defmodule Geometry do
		def rectangle_area(a, b) do
				...
		end
end
* defmodule и def не ключевые слова, а специальные конструкции – макросы
Если у функции нет аргументов, скобки можно опустить
В Elixir всё, что имеет возвращаемое значение, называется выражением. Возвращаемым значением функции в Elixir является результат ее последнего выражения, и функции не возвращают значение в явном виде.

\> оператор конвейера
iex(5)> -5 |> abs() |> Integer.to_string() |> IO.puts()

В общем случае оператор конвейера помещает результат предыдущего вызова на место первого аргумента следующего вызова. Таким образом, следующий код:
prev(arg1, arg2) |> next(arg3, arg4)
во время компиляции выглядит так:
next(prev(arg1, arg2), arg3, arg4)

-------------------------------------------------------
Арность функций
Арность – термин для обозначения количества передаваемых функции аргументов.
В Elixir принято обозначать функции как Rectangle.area/2, где /2 – это арность.
Две функции с одинаковым именем и разной арностью – это две абсолютно разные функции.
Чаще всего функция с меньшей арностью делегирует функции с большей арностью, передавая стандартные аргументы.
defmodule Calculator do
		def sum(a) do
				sum(a, 0)
		end
		def sum(a, b) do
				a + b
		end
end
Оператор \\, после которого указывается начальное значение аргумента
def fun(a, b \\ 1, c, d \\ 2) do ...
объявление функции с аргументами по умолчанию создает несколько функций с таким же именем и разной арностью
----------------------------------------------------
Видимость функций
Можно сделать функцию приватной, объявив ее при помощи мак­роса defp. Приватную функцию можно вызывать только в том модуле, в котором она определена.
-----------------------------------------------------
Импорты и псевдонимы
defmodule MyModule do
		import IO
		...
end
модуль стандартной библиотеки Kernel, содержащий наиболее часто используемые функции, по умолчанию импортируется в каждый новый модуль , список: https://hexdocs.pm/elixir/Kernel.html
alias – позволяет обращаться к модулю под другим именем:
defmodule MyModule do
		alias IO, as: MyIO
		...
end
-------------------------------------------------------
Атрибуты модулей
можно использовать как константы
defmodule Circle do
		@pi 3.14159
		def area(r), do: r*r*@pi
		def circumference(r), do: 2*r*@pi
end
* константа @pi существует только во время компиляции модуля
Aтрибут можно зарегистрировать, то есть поместить в сгенерированный бинарный файл и обратиться к нему во время выполнения программы

Некоторые атрибуты модулей регистрируются в Elixir по умолчанию. Например, атрибуты @moduledoc и @doc используются для предоставления документации к модулям и функциям:
для этого поместить в файл circle.ex,
defmodule Circle do
		@moduledoc "Implements basic circle functions"
		@pi 3.14159

		@doc "Computes the area of a circle"
		def area(r), do: r*r*@pi

		@doc "Computes the circumference of a circle"
		def circumference(r), do: 2*r*@pi
end
и выполнить команду  elixirc circle.ex, сгенерируется  Elixir.Circle.beam, после этого заработает
> Code.get_docs(Circle, :moduledoc)
{1, "Implements basic circle functions"}
такое тоже отработает в консоли iex
> h Circle.area
-----------------------------------------------------------

Для написания документации можно пользовать библиотеку ex_doc:
----------------------------------------------------------
Спецификации типов
Позволяет добавлять к функциям информацию о типе, которая далее будет проанализирована инструментом статического анализа кода dialyzer: http://erlang.org/doc/man/dialyzer.html
defmodule Circle do
		@spec area(number) :: number  # Спецификация типа для функции area/1, тип возвращаемого значения
		def area(r), do: r*r*@pi
end
подробней  https://hexdocs.pm/elixir/typespecs.html
---------------------------------------------------------
Комментарии
# Комментарий
a = 3.14 # Еще один комментарий
