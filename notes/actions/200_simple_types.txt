Числа
Целое число 3
Целое число в шестнадцатеричной системе 0xFF
Вещественное число 3.14
Экспоненциальная форма записи вещественного числа 1.0e-2
------------------------------------------
Поддерживаются стандартные арифметические операции.
Оператор деления / всегда возвращает вещест­венное число:
3/2 #-> 1.5
получить целое число:
div(5,2) #-> 2
получить остаток:
rem(5,2) #-> 1
можно визуально разделять классы числа:
1_000_000
===========================================
Атомы – это именованные константы.
:an_atom
:"an atom with spaces"
Атом состоит из двух частей – текста и значения.
наиболее подходящий вариант представления именованных констант
variable = :some_atom
-------------------------------------------
Псевдонимы - альтернативный синтаксис атомов
AnAtom
компилятор неявно добавляет префикс Elixir
iex(1)> AnAtom == :"Elixir.AnAtom" #-> true
--------------------------------------------
Логические атомы
Вместо логического типа используются атомы :true и :false
-------------------------------------------
Атом :nil
> nil == :nil #-> true
Атом nil в Elixir играет роль дополнительного средства для проверки истинности.
Атомы nil и false считаются ложными значениями, а все отличные от них – истинными.
Оператор || возвращает первое неложное значение:
iex(1)> nil || false || 5 || true #-> 5
Оператор && возвращает второе выражение, но только если первое является истинным.
> true && 5 #-> 5
> false && 5 #-> false
> nill && 5 #-> nill
Операторы, выполняющиеся по короткой схеме, – элегантный способ связывания нескольких операций
read_cached || read_from_disk || read_from_database
database_value = connection_established? && read_data
===============================================
Кортежи
Кортежи больше всего подходят для объединения фиксированного количества элементов.
что-то вроде нетипизированных структур или запи­сей
> person = {"Bob", 25} #-> {"Bob", 25}
> age = elem(person, 1) #-> 25
Функция put_elem не изменяет кортеж, а возвращает его новую версию, оставляя предыдущую нетронутой.
> put_elem(person, 1, 26) # -> {"Bob", 26}
> person #-> {"Bob", 25}
Для сохранения изменений присвоить в переменную
> older_person = put_elem(person, 1, 26)
> older_person #-> {"Bob",26}
К переменным также можно привязывать значение повторно:
> person = put_elem(person, 1, 26) #-> {"Bob", 26}
> person #-> {"Bob", 26}
================================================
Списки
Списки в Erlang используются для управления динамическими коллекциями данных переменного размера.
> prime_numbers = [2, 3, 5, 7]
списки работают как односвязные спис­ки, перебираются O(n)
> length(prime_numbers) #-> 4
получить элемент списка:
> Enum.at(prime_numbers, 3) #-> 7
содержит ли список тот или иной элемент?
> 5 in prime_numbers
заменяет элемент в заданной позиции(не изменит значение переменной):
> List.replace_at(prime_numbers, 0, 11)
> new_primes = List.replace_at(prime_numbers, 0, 11)
или переопределить
prime_numbers = List.replace_at(prime_numbers, 0, 11)
Вставить новый элемент в указанную позицию
> List.insert_at(prime_numbers, 3, 13)
добавить элемент в конец
> List.insert_at(prime_numbers, -1, 13)
оператор ++, объединяющий два списка:
> [1, 2, 3] ++ [4, 5] #-> [1, 2, 3, 4, 5]
-------------------------------------------------
Определение рекурсивного списка - голова, хвост
по сути сахар для определения списки a_list = [head | tail]
> [1 | [2, 3, 4]] #-> [1, 2, 3, 4]
> [1 | [2 | [3 | [4 | []]]]] #-> [1, 2, 3, 4]
Получить голову
> hd([1, 2, 3, 4]) #-> 1
Получить хвост
> tl([1, 2, 3, 4]) #-> [2, 3, 4]
* Хвост может быть абсолютно любого типа. В случае если он не является списком, это означает, что список неправильный
добавить элемент в начало можно просто:
> a_list = [5, :value, true]
> new_list = [:new_element | a_list] # -> [:new_element, 5, :value, true]
==================================================
Словари
Словарь – это хранилище пар ключ/значение, в качестве которых могут выступать
любые термы.
Динамические словари
> empty_map = %{}
> squares = %{1 => 1, 2 => 4, 3 => 9}
> squares = Map.new([{1, 1}, {2, 4}, {3, 9}]) #-> %{1 => 1, 2 => 4, 3 => 9}
получить значение по ключу
> squares[2] # если нет вернет nil
> Map.get(squares, 4, :not_found) # если нет вернет :not_found
> Map.fetch(squares, 2) #-> {:ok, 4}, усли нет вернёт :error
код выполняeтся тоько когда ключ присутствует в словаре
> Map.fetch!(squares, 2)

Функция Map.put/3 добавляет в словарь новый элемент:
iex(13)> squares = Map.put(squares, 4, 16)
---------------------------------------------------
Структурированные данные
объединение нескольких полей в единую структуру
например;
> bob = %{name: "Bob", age: 25, works_at: "Initech"}
вывести значение какого-либо поля
> bob[:works_at] #-> "Initech"
> bob[:non_existent_field] #-> nil
> bob.age #-> 25
> bob.non_existent_field #-> ** (KeyError) key :non_existent_field not found
Изменить значение поля
> next_years_bob = %{bob | age: 26}
> %{bob | age: 26, works_at: "Initrode"}
==================================================
Бинарные данные и битовые строки
бинарная последовательность из трех байтов:
> <<1, 2, 3>>
===================================================
Строки
реализуются либо бинарными последовательностями, либо списками.
---------------------------------------------------
Бинарные строки
> "This is a string" #-> "This is a string"
> ~s(This is also a string)
> ~s("Do... or do not. There is no try." -Master Yoda)
оператор конкатенации <>:
> "String" <> " " <> "concatenation"
встроенные в строки выражения
> "Embedded expression: #{3 + 0.14}"
интерполяция не производятся
> ~S(Not interpolated #{3 + 0.14})
экранирования символом обратного слеша (\)
> "\r \n \" \\"
экранирование не производятся
> ~S(Not escaped \n)
многострочный текст
> "
    This is
    a multiline string
    "
>   """
    Heredoc must end on its own line """
    """
-------------------------------------------------------
Списки символов
> 'ABC' #-> 'ABC' *одиночные кафычки
> [65, 66, 67] #-> 'ABC'
> 'Interpolation: #{3 + 0.14}'
> ~c(Character list sigil)
> ~C(Unescaped sigil #{3 + 0.14})
>   '''
    Heredoc
    '''
-----------------------------------------------------------
 преобразовать бинарную строку в список символов,
 > String.to_charlist("ABC")
 обратно List.to_string/1
