В Elixir переменной присваивается само определение функции, и чтобы вызвать функцию, достаточно обратиться к переменной.
создать переменную-функцию
square = fn x ->
    x * x
end
* Поскольку функция не привязана к глобальному имени, она называется анонимной функцией, или лямбда-функцией.
можно вызвать, указав имя переменной, после которого должен следовать символ точки (.) и аргументы:
> square.(5) #-> 25
Enum.each выводит элементы списка на экран:
print_element = fn x -> IO.puts(x) end
Enum.each(
    [1, 2, 3],
    print_element
)
:ok #Результат выполнения функции Enum.each

Вместо fn x → IO.puts(x) end можно просто написать &IO.puts/1
Enum.each(
    [1, 2, 3],
    &IO.puts/1
)

Оператор захвата &
> lambda = fn x, y, z -> x * y + z end
> lambda = &(&1 * &2 + &3)
---------------------------------------------------
Замыкания
Анонимная функция может ссылаться на любую переменную вне ее области видимости:
outside_var = 5
my_lambda = fn ->
    IO.puts(outside_var)
end

Повторная привязка переменной никак не влияет на ранее определенную анонимную функцию, ссылающуюся на то же символьное имя:
outside_var = 5
lambda = fn -> IO.puts(outside_var) end
outside_var = 6
lambda.() #-> 5
==================================================
Динамический вызов функций
apply(IO, :puts, ["Dynamic function call."])
Kernel.apply/3 передаются три аргумента: атом модуля, атом функ-
ции и список передаваемых функции аргументов
